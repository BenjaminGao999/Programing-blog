# 分布式锁的必要保证

1. 加锁和解锁操作必须是原子性的

2. 互斥锁

3. 加锁的client或线程挂了，锁必须被释放掉


4. 保证高可用性,避免单节点问题

5. 多节点下的保证加锁和释放锁的一致性

6. 加锁和解锁的高性能问题


7. 可重入锁

8. 死锁、活锁、 饥饿



  
# MySQL分布式锁
 借助事务的特性和回滚机制、超时连接事务失败并回滚，实现MySQL自动释放由下线的客户端添加的锁。
 
 1. 锁粒度
  锁住某个共享资源、 锁住某个操作、 锁住某个方法、 全局锁（所有用户中只能一个获取锁）、 用户锁（用户级别的锁）

 根据业务可以划分多种锁粒度



# Redis实现分布式锁



http://zhangtielei.com/posts/blog-redlock-reasoning.html
http://www.redis.cn/topics/distlock.html


Redis高可用集群
主从架构
 主节点写， 从节点复制主节点， 当主节点下线由从节点升级为主节点。

Redis 主从架构实现了高可用性， 但是牺牲了一致性  

Redis 为什么基于故障转移的实现还不够
为了更好的理解我们想要改进的方面，我们先分析一下当前大多数基于Redis的分布式锁现状和实现方法.

实现Redis分布式锁的最简单的方法就是在Redis中创建一个key，这个key有一个失效时间（TTL)，以保证锁最终会被自动释放掉（这个对应特性2）。当客户端释放资源(解锁）的时候，会删除掉这个key。

从表面上看，似乎效果还不错，但是这里有一个问题：这个架构中存在一个严重的单点失败问题。如果Redis挂了怎么办？你可能会说，可以通过增加一个slave节点解决这个问题。但这通常是行不通的。这样做，我们不能实现资源的独享,因为Redis的主从同步通常是异步的。

在这种场景（主从结构）中存在明显的竞态:

客户端A从master获取到锁
在master将锁同步到slave之前，master宕掉了。
slave节点被晋级为master节点
客户端B取得了同一个资源被客户端A已经获取到的另外一个锁。安全失效！
有时候程序就是这么巧，比如说正好一个节点挂掉的时候，多个客户端同时取到了锁。如果你可以接受这种小概率错误，那用这个基于复制的方案就完全没有问题。否则的话，我们建议你实现下面描述的解决方案。







